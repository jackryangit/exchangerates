# Exchange Rate Application

This is a small Java application built with Spring Boot that fetches exchange rates from two different APIs, calculates the average, caches the results, and exposes operational metrics. 

**Core Features:**
* Fetches rates from [Free Currency Rates API](https://github.com/fawazahmed0/exchange-api) and [Frankfurter](https://www.frankfurter.app).
* Calculates the average rate for each requested currency.
* Caches results to serve identical requests instantly.
* Exposes metrics for monitoring.

---

## How to Build and Run

You will need **Java 17** and **Maven** installed.

1.  **Clone the repository:**
    ```sh
    git clone git@github.com:jackryangit/exchangerates.git
    cd exchangerates
    ```

2.  **Build the project:**
    ```sh
    mvn clean install
    ```

3.  **Run the application:**
    ```sh
    mvn spring-boot:run
    ```

The application will start on port `8080`.

---


## Endpoints

### Get Exchange Rates

Fetches and calculates the average exchange rates for a given base currency.

* **Endpoint:** `GET /exchangeRates/{baseCur}?symbols={symbols}`
* **URL Params:**
  * `baseCur` (String, required): The base currency code (e.g., `EUR`).
  * `symbols` (String, required): A comma-separated list of target currency codes (e.g., `USD,NZD`).
* **Success Response (200 OK):**
    ```json
    {
      "base": "EUR",
      "rates": {
        "USD": 1.076,
        "NZD": 1.765
      }
    }
    ```

### Get Metrics

Provides metrics about application usage.

* **Endpoint:** `GET /metrics`
* **Success Response (200 OK):**
    ```json
    {
      "totalQueries": 15,
      "apis": [
        {
          "name": "frankfurter",
          "metrics": {
            "totalRequests": 10,
            "totalResponses": 9
          }
        },
        {
          "name": "freeCurrencyApi",
          "metrics": {
            "totalRequests": 10,
            "totalResponses": 10
          }
        }
      ]
    }
    ```
  
---


## Tests

To run the unit tests for the project, execute the following Maven command:

```sh
mvn test
```

This will run all classes ending in `*Test.java` in the `src/test/java` directory.

---


## Design and Rationale

### Technology Stack

* **Java 17:** A modern and stable version of Java.
* **Spring Boot 3:** Chosen for its rapid development capabilities, dependency injection, and seamless integration of web, caching, and metrics modules.
* **Maven:** For dependency management and building the project.
* **Caffeine:** An in-memory caching library that is easy to configure with Spring Boot.
* **JUnit 5 & Mockito:** For unit testing.

### Architecture

The application follows a standard layered architecture to separate concerns, making it clean and maintainable.

* **Controller Layer (`controller`):** Handles incoming HTTP requests for `/exchangeRates` and `/metrics`. It validates input and delegates business logic to the service layer.
* **Service Layer (`service`):**
    * `ExchangeRateService`: : Orchestrates the fetching of exchange rate data from various external API clients. It then applies the core business logic, which involves averaging the rates received from different sources..
    * `ExchangeRateFetcher`:This component handles the actual fetching of data from external sources and incorporates caching (`@Cacheable`) to optimize performance and reduce redundant API calls..
    * `MetricsService`: A central place to define and increment our custom metrics. It is injected into other services and clients where metrics need to be recorded.
* **Client Layer (`client`):** Contains components responsible for communicating with the external APIs. Each client (`FrankfurterClient`, `FreeCurrencyClient`) handles the specifics of one external API, including its URL structure and response format (DTOs). This isolates external dependencies.
* **DTOs (`dto`):** Data Transfer Objects are used to model the JSON responses from both our application and the external APIs, ensuring type safety.

This design makes the system extensible. To add a new API provider, one would only need to add a new class in the `client` package and update the `ExchangeRateService` to use it.

### Caching Strategy

Performance and rate-limiting are critical when dealing with external APIs. I chose an in-memory caching strategy using **Caffeine** via Spring's `@Cacheable` abstraction.

* **Implementation:** A `CacheManager` is configured in `CachingConfig.java`. The `@Cacheable()` annotation on the `fetchFrankfurterRates` & `fetchFreeApiRates` methods in the `ExchangeRateFetcher` handles the caching automatically. The cache key is generated by Spring based on the base currency.
* **Eviction Policy:** The cache is configured to expire entries 10 minutes after they are written to ensure the rates are not too stale.

## Possible Improvements

Given more time, I would focus on the following enhancements:

* **Asynchronous API Calls:** Use `CompletableFuture` or something similar to call the external APIs in parallel. Whilst it doesn't make a huge difference with two endpoints, if more were added, this would significantly reduce the response time of the main endpoint.

* **Robust Error Handling & Resiliency:**
  * Implement a **Circuit Breaker** . If an external API is down, the circuit breaker would "open" and prevent further calls for a period, stopping the application from wasting resources on failing requests.
  * Add a **retry mechanism** for transient network errors.

* **Configuration Management:**
  * Externalize API URLs and cache settings (like TTL) into `application.properties` to allow for easier configuration without changing the code.
  * Use Spring Profiles (`application-dev.properties`, `application-prod.properties`) to manage different configurations for different environments.

* **Containerization:**
  * Provide a `Dockerfile` to containerize the application, making deployment and scaling with tools like Docker Compose or Kubernetes much simpler.


